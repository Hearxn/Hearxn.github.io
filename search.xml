<?xml version="1.0" encoding="utf-8"?>
<search>
  <entry>
    <title><![CDATA[异常处理]]></title>
    <url>%2F%E5%BC%82%E5%B8%B8%E5%A4%84%E7%90%86.html</url>
    <content type="text"><![CDATA[¶异常 ¶含义 java语言中,将程序执行中发生的不正常情况 ¶分类 1.Error: Java虚拟机无法解决的严重问题. 2.Exception: 其他因编程错误或者偶然的外在因素导致的一般性问题,使用针对性的代码进行处理. ¶体系结构 1.编译时异常; 2.运行时异常. ¶处理方式 ¶try-catch-finally 1.catch中的异常类型如果没有子父类关系,则异常顺序无所谓. 2.catch中的异常类型如果满足子父类关系,则要求子类一定要声明在父类的上面 ¶throws+异常类型 throws的方式只是将异常抛给了方法的调用者 ¶throw与throws的不同 throw表示抛出一个异常类的对象,声明异常对象的过程,声明在方法体内; throws属于异常处理的一种方式,声明在方法的声明处.]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[认识单例模式]]></title>
    <url>%2F%E8%AE%A4%E8%AF%86%E5%8D%95%E4%BE%8B%E6%A8%A1%E5%BC%8F.html</url>
    <content type="text"><![CDATA[¶饿汉模式 提到&quot;饿汉模式&quot;,相信很多人跟我一样一脸懵逼,为什么叫&quot;饿汉&quot;?为了清楚理解&quot;饿汉模式&quot;,请允许我给你们介绍另一个概念: “立即加载”.什么是立即加载?立即加载就是我们在使用类的时候已经将对象创建完毕,常见的的实现方式就是直接new对象.而立即加载从语义来看,有着&quot;急切,马上&quot;的含义,所以称为&quot;饿汉模式&quot;. &quot;饿汉模式&quot;是在调用方法之前,实例对象已经被创建.接下来用代码进行演示 123456789101112131415161718192021222324252627package com.xiebin.day5;/** * @author 谢斌 * @create 2019/10/24 * 立即加载 == 饿汉模式 */public class SingletonTest &#123; /* * static 关键字随着类的加载而加载,在内存中只有那一份; * private关键字不允许外界进行访问 * */ private static SingletonTest singletonTest = new SingletonTest(); //不能通过new的方式创建对象 private SingletonTest()&#123; &#125; public static SingletonTest getInstance()&#123; /* * 1.此版本代码的缺点是不能有其他实例变量; * 2.getInstance()方法没有同步,有可能存在线程安全问题 * */ return singletonTest; &#125;&#125; 123456789101112package com.xiebin.day5;/** * @author 谢斌 * @create 2019-10-2019/10/24 */public class MyThread extends Thread&#123; @Override public void run() &#123; System.out.println(SingletonTest.getInstance().hashCode()); &#125;&#125; 1234567891011121314151617package com.xiebin.day5;/** * @author 谢斌 * @create 2019-10-2019/10/24 */public class MyRun &#123; public static void main(String[] args) &#123; MyThread m1 = new MyThread(); MyThread m2 = new MyThread(); MyThread m3 = new MyThread(); m1.start(); m2.start(); m3.start(); &#125;&#125; ¶懒汉模式 延迟加载就是在调用get()方法时实例才被创建.常见方法就是在get方法中进行new对象. ¶单线程 123456789101112131415161718192021package com.xiebin.day5;/** * @author 谢斌 * @create 2019-10-2019/10/24 */public class MySingleton &#123; private static MySingleton mySingleton; private MySingleton()&#123; &#125; public static MySingleton getInstance()&#123; //延迟加载 if (mySingleton == null) &#123; mySingleton = new MySingleton(); &#125; return mySingleton; &#125;&#125; 123456789101112package com.xiebin.day5;/** * @author 谢斌 * @create 2019-10-2019/10/25 16:40 */public class MyThread extends Thread &#123; @Override public void run() &#123; System.out.println(MySingleton.getInstance().hashCode()); &#125;&#125; 123456789101112131415161718192021222324package com.xiebin.day5;/** * @author 谢斌 * @create 2019-10-2019/10/25 16:41 */public class MyRun &#123; public static void main(String[] args) &#123; MyThread m1 = new MyThread(); MyThread m2 = new MyThread(); MyThread m3 = new MyThread(); m1.start(); m2.start(); m3.start(); &#125;&#125;--------------------------------------------------连接到目标 VM，地址：'127.0.0.1:51282', transport: 'socket'767501637767501637767501637断开与目标 VM 的连接，地址：'127.0.0.1:51282', transport: 'socket' ¶多线程 123456789101112131415161718192021222324252627282930package com.xiebin.day5;/** * @author 谢斌 * @create 2019-10-2019/10/24 */public class MySingleton &#123; private static MySingleton mySingleton; private MySingleton()&#123; &#125; public static MySingleton getInstance()&#123; //延迟加载 if (mySingleton == null) &#123; try &#123; Thread.sleep(3000); mySingleton = new MySingleton(); &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; &#125; return mySingleton; &#125;&#125;----------------------------------4535946677047375051372676747 在多线程环境下,控制台打印了3个不同的hashcode值,说明创建了三个不同的对象,违背了单例模式的本意 ¶优化方法 ¶声明synchronize关键字 既然多个线程可以同时访问getInstance()方法,那么我们在这个方法上加把锁,在一段时间内只能有一个线程访问getInstance()方法. 1234567891011121314151617181920212223242526272829303132333435package com.xiebin.day5;/** * @author 谢斌 * @create 2019-10-2019/10/24 */public class MySingleton &#123; private static MySingleton mySingleton; private MySingleton() &#123; &#125; /* * 设置同步方法效率低,整个方法被上锁 * * */ synchronized public static MySingleton getInstance() &#123; //延迟加载 try &#123; if (mySingleton == null) &#123; Thread.sleep(3000); mySingleton = new MySingleton(); &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return mySingleton; &#125;&#125;----------------------------------128709439412870943941287094394 上述方式是同步运行的,下一个线程要取得对象,就必须等上一个线程释放锁之后,才能继续执行,.效率低下.继续改写代码解决这个缺点 ¶同步代码块 同步代码块可以针对某些重要的代码进行单独的同步,这样效率可以大幅度提升. 1234567891011121314151617181920212223242526272829303132package com.xiebin.day5;/** * @author 谢斌 * @create 2019-10-2019/10/24 */public class MySingleton &#123; private static MySingleton mySingleton; private MySingleton() &#123; &#125; public static MySingleton getInstance() &#123; //延迟加载 try &#123; if (mySingleton == null) &#123; Thread.sleep(3000); synchronized (MySingleton.class) &#123; mySingleton = new MySingleton(); &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return mySingleton; &#125;&#125;-----------------------------5476861091391273746738978376 ¶使用DCL双检查锁机制 1234567891011121314151617181920212223242526272829package com.xiebin.day5;/** * @author 谢斌 * @create 2019-10-2019/10/24 */public class MySingleton &#123; private static MySingleton mySingleton; private MySingleton() &#123; &#125; public static MySingleton getInstance() &#123; //延迟加载 try &#123; if (mySingleton == null) &#123; Thread.sleep(3000); synchronized (MySingleton.class) &#123; if (mySingleton == null) &#123; mySingleton = new MySingleton(); &#125; &#125; &#125; &#125; catch (InterruptedException e) &#123; e.printStackTrace(); &#125; return mySingleton; &#125;&#125; 由于DCL无法解决指令重排的问题,需要关键字volatile禁止指令重排,在多线程环境下,使用DCL双检锁+volatile结合才能符合单例模式的要求 ¶使用静态内部类 123456789101112131415161718192021222324package com.xiebin.day5;/** * @author 谢斌 * @create 2019-10-2019/10/24 */public class MySingleton &#123; //内部类方式 private static class MyHolder &#123; private static MySingleton mySingleton = new MySingleton(); &#125; private MySingleton() &#123; &#125; public static MySingleton getInstance()&#123; return MyHolder.mySingleton; &#125;&#125;------------------------704737505704737505704737505 ¶序列化与反序列化 未完待续… ¶使用static代码块 特性: 利用static 带块随着类的加载而执行且只执行一次 12345678910111213141516171819202122package com.xiebin.day5;/** * @author 谢斌 * @create 2019-10-2019/10/24 */public class MySingleton &#123; private static MySingleton instance = null; private MySingleton()&#123; &#125; static &#123; instance = new MySingleton(); &#125; public static MySingleton getInstance()&#123; return instance; &#125;&#125; ¶使用枚举类 特性: 在使用枚举类时,构造方法会被自动调用 123456789101112131415161718192021222324package com.xiebin.day5;/** * @author 谢斌 * @create 2019-10-2019/10/24 */public class MySingleton &#123;private MySingleton()&#123;&#125;private enum Singleton&#123; INSTANCE; private final MySingleton instance; Singleton()&#123; instance = new MySingleton(); &#125; private MySingleton getInstance()&#123; return instance; &#125;&#125;public static MySingleton getInstance()&#123; return Singleton.INSTANCE.getInstance(); &#125;&#125;]]></content>
      <categories>
        <category>java设计模式</category>
      </categories>
      <tags>
        <tag>程序员基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我没有“对象”]]></title>
    <url>%2F%E6%88%91%E6%B2%A1%E6%9C%89%E2%80%9C%E5%AF%B9%E8%B1%A1%E2%80%9D.html</url>
    <content type="text"><![CDATA[¶类与对象 ¶三大特征 面向对象四大特征: 封装、继承、多态. ¶Object类和包装类 ¶equals 1234567 Student st1 = new Student("小明",12); Student st2 = new Student("小明",12); System.out.println(st1.equals(st2)); //false-------------------------------------- String s1 = new String("哈啊哈哈"); String s1 = new String("哈啊哈哈"); System.out.println(s1.equals(s2)); //true 大家都知道引用数据类型变量保存的是地址值,equals()方法比较是对象的内容,上述两组代码比较的内容一样,为啥结果却不一样,不要着急,我们首先看看Object类中的equals方法的源码 123public boolean equals(Object obj) &#123; return (this == obj);&#125; 观看源码才发现,Object类中的equals方法实际上比较的是地址值,Object类是根父类,而Student类并没有重写equals方法.所以st1 不等于st2. 12345678910111213141516171819202122 public boolean equals(Object anObject) &#123; if (this == anObject) &#123; //上来就比较俩变量的地址值是否相等 return true; &#125; if (anObject instanceof String) &#123;//判断anObject是否属于String类型 String anotherString = (String)anObject;//强转anObject类型为String int n = value.length; //字符数组的长度,也就是字符串的长度 if (n == anotherString.value.length) &#123;//比较两字符串的长度是否相等 char v1[] = value; char v2[] = anotherString.value; int i = 0; while (n-- != 0) &#123; if (v1[i] != v2[i]) return false; i++; &#125; return true; &#125; &#125; return false;//不是String类型,就直接返回false &#125;//比较每一个字符是否相等 由于String类对Object类的equals方法进行重写,确立比较每一个字符相等.所以s1 == s2. ¶自定义类重写equals方法 123456789101112131415public boolean equals(Object obj)&#123; if(this == obj)&#123; return true; &#125; if(obj instanceof Student)&#123; Student cust = (Student) obj; //比较两个对象的每个属性是否都相同 if(this.age == cust.age &amp;&amp; this.name.equals(cust.name))&#123; return true; &#125;else&#123; return false; &#125; &#125; return false;&#125; ¶接口与抽象]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[Hello,数组]]></title>
    <url>%2FHello-%E6%95%B0%E7%BB%84.html</url>
    <content type="text"><![CDATA[数组的思维导图 ¶数组的赋值 ¶杨辉三角 123456789101112131415161718192021222324252627282930313233343536373839404142434445464748495051525354555657585960616263package com.xiebin.day4;/** * @author 谢斌 * @create 2019-10-2019/10/18 18:46 */public class ArrayExer &#123; public static void main(String[] args) &#123; //打印10行的杨辉三角 /* * 思路分析: * 1.声明与初始化二维数组 * 2.给数组的元素赋值 * 3.遍历数组,展示效果 * */ //1.声明与初始化二维数组 int [][] yangHui = new int[10][]; //2.给数组的元素赋值 /* * yangHui[0] = new int[1]; * yangHui[1] = new int[2]; * */ for (int i = 0; i &lt;yangHui.length ; i++) &#123; yangHui[i] = new int[i+1]; //给首末元素赋值 yangHui[i][0] = 1; yangHui[i][i] = 1; //给每行的非首末元素赋值 if (i &gt; 1)&#123; for (int j = 1; j &lt; yangHui[i].length - 1; j++) &#123; yangHui[i][j] = yangHui[i -1][j -1] +yangHui[i - 1][j]; &#125; &#125; &#125; //3.遍历数组,展示效果 for (int i = 0; i &lt; yangHui.length; i++) &#123; for (int j = 0; j &lt; yangHui[i].length; j++) &#123; System.out.print(yangHui[i][j] + "\t"); &#125; System.out.println(); &#125; &#125;&#125;=================================================输出结果:连接到目标 VM，地址：'127.0.0.1:59938', transport: 'socket'1 1 1 1 2 1 1 3 3 1 1 4 6 4 1 1 5 10 10 5 1 1 6 15 20 15 6 1 1 7 21 35 35 21 7 1 1 8 28 56 70 56 28 8 1 1 9 36 84 126 126 84 36 9 1 断开与目标 VM 的连接，地址：'127.0.0.1:59938', transport: 'socket'进程已结束，退出代码 0 ¶数组的复制 数组的复制:1.for循环复制;2.clone复制;3.System.arraycopy复制;4.Arrays.copyof复制 ¶for循环复制 数组属于引用数据类型,变量保存的是地址值. 12345678910111213141516171819202122232425262728293031323334353637383940package com.xiebin.day4;/** * @author 谢斌 * @create 2019-10-2019/10/18 */public class ArrayCopy1 &#123; public static void main(String[] args) &#123; //定义两个数组 int[] arr,arr2; //数组arr静态初始化 arr = new int[]&#123;1,2,3,4,5,6&#125;; //遍历数组中的元素 for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + "\t"); &#125; //把变量arr2赋值给变量arr arr2 = arr; //修改arr2中偶索引的元素,使其等于索引值 for (int i = 0; i &lt; arr2.length; i++) &#123; if (i % 2 == 0)&#123; arr2[i] = i; &#125; &#125; System.out.println(); //遍历arr for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + "\t"); &#125; System.out.println(); System.out.println("arr = " + arr); System.out.println("arr2 = " + arr2); &#125;&#125;============================1 2 3 4 5 6 0 2 2 4 4 6 arr = [I@7a7b0070arr2 = [I@7a7b0070 通过上述代码我们可以知道, arr2 = arr;这一步只是把arr保存的地址值[I@7a7b0070赋值给arr2,所以arr和arr 保存的是同一个地址值,修改arr2元素的值,arr元素的值也会随着改变.我们通过画图看看其怎么变化的 1234567891011121314151617181920212223242526272829303132package com.xiebin.day4;/** * @author 谢斌 * @create 2019-10-2019/10/18 */public class ArrayCopy &#123; public static void main(String[] args)&#123; //定义两个数组 int[] arr = new int[]&#123;1,2,3,4,5,6&#125;; int [] arr2 = new int[arr.length]; //通过for循环遍历进行数组的复制,并打印数组arr2 for (int i = 0; i &lt; arr2.length; i++) &#123; arr2[i] = arr[i]; System.out.print(arr2[i]); &#125; System.out.println(); //修改数组arr元素的值,看数组arr2看是否发生变化 arr[0] = 100; for (int i = 0; i &lt; arr2.length; i++) &#123; System.out.print(arr2[i]); &#125; System.out.println(); System.out.println("arr2 = " + arr2); System.out.println("arr = " + arr); &#125;&#125;==================123456123456arr2 = [I@1b6d3586arr = [I@4554617c 通过for循环把arr复制给arr2,然后修改arr数组第一个元素的值发现arr2数组对应位置的值没有变,说明两个变量指向的不是同一块地址. 12345678910111213141516171819202122232425262728293031package com.xiebin.day4;/** * @author 谢斌 * @create 2019-10-2019/10/18 */public class Arraycopy2 &#123; public static void main(String[] args) &#123; //定义引用数据类型的数组arr String[] arr = new String[]&#123;"AA","BB","CC","DD","EE","FF"&#125;; //数组的复制 String[] arr2 = new String[arr.length]; for (int i = 0; i &lt; arr2.length; i++) &#123; arr2[i] = arr[i]; System.out.print("arr2数组元素"+arr2[i]+"\t"); &#125; System.out.println(); //遍历arr数组 for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print("arr = " + arr[i]+"\t"); &#125; System.out.println(); //修改数组arr第一个元素的位置 arr[0] = "aa"; for (int i = 0; i &lt; arr2.length; i++) &#123; System.out.print(arr2[i]+"\t"); &#125; &#125;&#125; ¶clone复制 12345678910111213141516171819202122232425262728293031323334353637383940414243444546474849package com.xiebin.day4;/** * @author 谢斌 * @create 2019-10-2019/10/18 */public class ArrayClone &#123; public static void main(String[] args) &#123; //定义数组arr,arr2 int[] arr = &#123;1,2,3,4,5&#125;; int[] arr2 = new int[arr.length]; //进行复制 arr2 = arr.clone(); //遍历数组arr和arr2 for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i]+"\t"); &#125; System.out.println(); for (int i = 0; i &lt; arr2.length; i++) &#123; System.out.print(arr2[i]+"\t"); &#125; System.out.println(); System.out.println("=========================="); //改变数组arr元素的值 arr[0] = 10; //遍历数组arr和arr2 for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i]+"\t"); &#125; System.out.println(); for (int i = 0; i &lt; arr2.length; i++) &#123; System.out.print(arr2[i]+"\t"); &#125; System.out.println(); System.out.println("arr2 = " + arr2); System.out.println("arr = " + arr); &#125;&#125;------------------------------------------------------------1 2 3 4 5 1 2 3 4 5 ==========================10 2 3 4 5 1 2 3 4 5 arr2 = [I@1b6d3586arr = [I@4554617c 通过上述代码的演示,我们发现,通过clone方法进行数组的复制,通过改变数组arr元素的值,然后arr2对应位置元素的值却没有发生改变,说明两数组变量保存的不是同一个地址值.我们打印两个数组的地址值发现,地址值不同. 总结: 一维数组：深克隆；（重新分配空间，并将元素复制过去） 二维数组：浅克隆。（只传递引用） 分析:这里采用&quot;数组降维度&quot;的思想,一维数组降维度就成为元素,基本数据类型;而二维数组降维度就为一维数组,数组是引用数据类型,复制的是引用. 浅复制和深复制 浅拷贝只复制指向某个对象的指针，而不复制对象本身，新旧对象还是共享同一块内存。但深拷贝会另外创造一个一模一样的对象，新对象跟原对象不共享内存，修改新对象不会改到原对象 ; 深拷贝指的是对象A复制给对象B时，A和B指向的不是同一个对象，通时A的对象成员AA和B的对象成员BB也指的不是同一个对象，如有更深层对象，以此类推。 浅克隆中，当对象被复制时只复制它本身和其中包含的值类型的成员变量，而引用类型的成员对象并没有复制 在Java语言中，通过覆盖Object类的clone()方法可以实现浅克隆。 在深克隆中，除了对象本身被复制外，对象所包含的所有成员变量也将复制。 在Java语言中，如果需要**实现深克隆，可以通过*覆盖Object类的clone()方法实现，也*可以通过序列化(Serialization)等方式来实现。 Java语言提供的Cloneable接口和Serializable接口的代码非常简单，它们都是空接口，这种空接口也称为标识接口，标识接口中没有任何方法的定义，其作用是告诉JRE这些接口的实现类是否具有某个功能，如是否支持克隆、是否支持序列化等。 实现对象克隆有两种方式： 1). 实现Cloneable接口并重写Object类中的clone()方法； 2). 实现Serializable接口，通过对象的序列化和反序列化实现克隆，可以实现真正的深度克隆。 ¶System.arraycopy() 12345678910111213System.arraycopy()源码 * @param src 原数组. * @param srcPos 从原数组的那个位置开始拷贝. * @param dest 目标数组. * @param destPos 拷贝到目标数组的位置. * @param length 拷贝数组的长度. * @exception IndexOutOfBoundsException 索引越界异常. * @exception ArrayStoreException . * @exception NullPointerException 空指针异常. */ public static native void arraycopy(Object src, int srcPos, Object dest, int destPos, int length); 1234567891011121314151617181920212223242526272829303132333435package com.xiebin.day4;/** * @author 谢斌 * @create 2019-10-2019/10/19 */public class ArrayCopy3 &#123; public static void main(String[] args) &#123; //定义数组arr和arr2 int[] arr = new int[]&#123;1,2,3,4,5&#125;; int[] arr2 = new int[arr.length]; //进行复制 System.arraycopy(arr,0,arr2,0,arr.length); System.out.println("-------------------------------------"); //改变arr元素的值 arr[0] = 100; //遍历数组arr和arr2 for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i]+"\t"); &#125; System.out.println(); for (int i = 0; i &lt; arr2.length; i++) &#123; System.out.print(arr2[i]+"\t"); &#125; System.out.println(); System.out.println("arr2 = " + arr2); System.out.println("arr = " + arr); &#125;&#125;=========================-------------------------------------100 2 3 4 5 1 2 3 4 5 arr2 = [I@1b6d3586arr = [I@4554617c ¶Arrays.copyof() 首先看下它的源码 123456public static int[] copyOf(int[] original, int newLength) &#123; int[] copy = new int[newLength]; System.arraycopy(original, 0, copy, 0, Math.min(original.length, newLength)); return copy; &#125; 此方法需要两个参数,原始数组,新数组的长度.该方法底层 调用了System.arraycopy ,返回是一个原始数组的副本 1234567891011121314151617181920212223242526272829303132333435package com.xiebin.day4;import java.util.Arrays;/** * @author 谢斌 * @create 2019-10-2019/10/19 */public class ArrayCopy3 &#123; public static void main(String[] args) &#123; //定义数组arr和arr2 int[] arr = new int[]&#123;1,2,3,4,5&#125;; int[] arr2 = new int[arr.length]; //进行复制 arr2 = Arrays.copyOf(arr, arr.length); //改变arr元素的值 arr[0] = 100; //遍历数组arr和arr2 for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i]+"\t"); &#125; System.out.println(); for (int i = 0; i &lt; arr2.length; i++) &#123; System.out.print(arr2[i]+"\t"); &#125; System.out.println(); System.out.println("arr2 = " + arr2); System.out.println("arr = " + arr); &#125;&#125;-------------------------------100 2 3 4 5 1 2 3 4 5 arr2 = [I@1b6d3586arr = [I@4554617c ¶Arrays.copyOfRange 123456789101112131415//源码分析//原始数组,从哪个索引开始复制,到哪个位置为止public static int[] copyOfRange(int[] original, int from, int to) &#123; //新数组的长度 int newLength = to - from; if (newLength &lt; 0) //抛出非法参数异常 throw new IllegalArgumentException(from + " &gt; " + to); //创建副本数组copy int[] copy = new int[newLength]; //调用System.arraycopy System.arraycopy(original, from, copy, 0, Math.min(original.length - from, newLength)); //返回一个原数组的副本 return copy; 1234567891011121314151617181920212223242526272829303132333435package com.xiebin.day4;import java.util.Arrays;/** * @author 谢斌 * @create 2019-10-2019/10/19 */public class ArrayCopy3 &#123; public static void main(String[] args) &#123; //定义数组arr和arr2 int[] arr = new int[]&#123;1,2,3,4,5&#125;; int[] arr2 = new int[arr.length]; //进行复制 arr2 = Arrays.copyOfRange(arr,0,arr.length); //改变arr元素的值 arr[0] = 100; //遍历数组arr和arr2 for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i]+"\t"); &#125; System.out.println(); for (int i = 0; i &lt; arr2.length; i++) &#123; System.out.print(arr2[i]+"\t"); &#125; System.out.println(); System.out.println("arr2 = " + arr2); System.out.println("arr = " + arr); &#125;&#125;===================100 2 3 4 5 1 2 3 4 5 arr2 = [I@1b6d3586arr = [I@4554617c 数组的反转 1234567891011121314151617181920212223package com.xiebin.day4;/** * @author 谢斌 * @create 2019-10-2019/10/18 */public class Arraycopy2 &#123; public static void main(String[] args) &#123; //定义引用数据类型的数组arr String[] arr = new String[]&#123;"AA","BB","CC","DD","EE","FF"&#125;; //数组的反转 for (int i = 0; i &lt; arr.length/2; i++) &#123; String temp = arr[i]; arr[i] = arr[arr.length - i -1]; arr[arr.length - i -1] = temp; &#125; //数组的遍历 for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i] + "\t"); &#125; &#125;&#125; ¶数组的查找 ¶线性查找 1234/* 线性查找:也叫线性搜索,从数组中搜索元素的算法,从头按顺序重复比较的方法; 数据量很大时,比较次数会增加,需要花费大量时间.*/ 1234567891011121314151617181920212223242526272829package com.xiebin.day4;/** * @author 谢斌 * @create 2019-10-2019/10/18 */public class Arraycopy2 &#123; public static void main(String[] args) &#123; //定义数组arr String[] arr = new String[]&#123;"AA", "BB", "CC", "DD", "EE", "FF"&#125;; //搜索: "EE" String dest = "EE"; //遍历数组,并与dest重复比较 //定义标识符 boolean flag = true; for (int i = 0; i &lt; arr.length; i++) &#123; if (dest.equals(arr[i])) &#123; System.out.println("找到啦,i = " + i); flag = false; break; &#125; &#125; if (flag == true) &#123; System.out.println("对不起,没有找到"); &#125; &#125;&#125; ¶二分法查找 12345678910111213141516171819202122232425262728293031323334353637383940package com.xiebin.day4;/** * @author 谢斌 * @create 2019-10-2019/10/19 *//*二分搜索: 从有序数组中搜索元素的算法.*/public class ArraySeach &#123; public static void main(String[] args) &#123; //定义数组arr int[] arr = new int[]&#123;-98,-34,2,34,54,66,79,105,210,333&#125;; //搜索目标:-34 int dest = -34; //初始首索引 int head = 0; //初始末索引 int end = arr.length-1; boolean flag = true; while(head &lt;= end)&#123; int middle = (head + end)/2; if (dest == arr[middle])&#123; System.out.println("找到了指定位置,位置为: " + middle); flag = false; break; &#125;else if (arr[middle] &gt; dest)&#123; end = middle -1; &#125;else&#123; head = middle + 1; &#125; &#125; if (flag)&#123; System.out.println("没有找到"); &#125; &#125;&#125; ¶数组的排序 ¶冒泡排序 123456789101112131415161718192021222324252627package com.xiebin.day5;/** * @author 谢斌 * @create 2019-10-2019/10/19 * 排序思想：两两元素进行比较后交换位置 */public class ArraySort &#123; public static void main(String[] args) &#123; int[] arr = &#123;43,32,76,-98,0,64,33,-21,32,99&#125;; //外层循环控制排序趟数 for (int i = 0; i &lt; arr.length-1; i++) &#123; //内层循环控制每一趟排序多少次 for (int j = 0; j &lt; arr.length - 1 - i; j++) &#123; if (arr[j] &gt; arr[j + 1])&#123; int temp = arr[j]; arr[j] = arr[j+1]; arr[j+1] = temp; &#125; &#125; &#125; for (int i = 0; i &lt; arr.length; i++) &#123; System.out.print(arr[i]+"\t"); &#125; &#125;&#125;]]></content>
      <categories>
        <category>javaSE</category>
      </categories>
      <tags>
        <tag>java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[java基础语法]]></title>
    <url>%2Fjava%E5%9F%BA%E7%A1%80%E8%AF%AD%E6%B3%95.html</url>
    <content type="text"><![CDATA[¶第一阶段 我把自己的学习笔记用思维导图的方式记录下来,如下图所示: ¶第二阶段 关于自增的代码,可以发现:前++会先进行自增1,再进行赋值运算;而后++会先进行赋值运算,再进行自增.不管是前++还是后++,变量本身最终会自增1. 123456789101112131415161718192021222324252627282930package com.xiebin.day01;/** * @author 谢斌 * @create 2019-10-2019/10/13 14:14 */public class AriTest &#123; public static void main(String[] args) &#123; int a1 = 10; int b1 = ++a1; System.out.println("b1 = " + b1); System.out.println("a1 = " + a1); System.out.println("*****************"); int a2 = 10; int b2 = a2++; System.out.println("b2 = " + b2); System.out.println("a2 = " + a2); &#125;&#125;输出结果为: b1 = 11 a1 = 11 ***************** b2 = 10 a2 = 11 进程已结束，退出代码 0 123456789package com.xiebin.day01;public class AriTest &#123; public static void main(String[] args) &#123; byte b1 = 127; b1++; System.out.println("b1 = " + b1);//-128? &#125;&#125; 分析:首先byte的范围是-128~127.字节长度为8位,左边是符号位;而127的二进制为 :0111 1111，所以执行 b1++;时，0111 111变为1000 0000，而128的二进制为：1000 0000，最高位为符号位. ¶第三阶段 这阶段主要是流程控制语句: if语句、switch语句 和循环语句. 通过练习题加强对知识的理解.下面附上代码 1234567891011121314151617181920212223242526272829303132333435363738package com.xiebin.day02;import java.util.Scanner;/** * @author 谢斌 * @create 2019/10/15 8:54 */public class exer1 &#123; public static void main(String[] args) &#123; /*有3个整数，给出提示信息： 能否创建三角形；两边之和大于第三边 三个条件都要写 如果能构建三角形，提示是直角三角形还是等边三角形等腰三角形还是普通三角形； 最后输出三角形面积；*/ Scanner as = new Scanner(System.in); System.out.println("请输入第一个整数:"); int a = as.nextInt(); System.out.println("请输入第二个整数"); int b = as.nextInt(); System.out.println("请输入第三个整数"); int c = as.nextInt(); double s = (a + b + c) / 2; double sr = Math.sqrt(s * (s - a) * (s - b) * (s - c)); if ((a + b) &gt; c &amp;&amp; (b + c) &gt; a &amp;&amp; (c + a) &gt; b) &#123; System.out.println("能构建三角形"); if ((a * a + b * b) == c * c || (b * b + c * c) == a * a || (c * c + a * a) == b * b) &#123; System.out.println("该三角形是直角三角形"); System.out.println("三角形面积 = " + sr); &#125; else if (a == b &amp;&amp; b == c &amp;&amp; c == a) &#123; System.out.println("三角形为等边三角形"); System.out.println("三角形面积 = " + sr); &#125; else if (a == b || b == c || c == a) &#123; System.out.println("该三角形是等边三角形"); System.out.println("三角形面积 = " + sr); &#125; &#125; else &#123; System.out.println("不能构建三角形"); &#125; &#125;&#125; ¶求100以内的所有质数 1234567891011121314151617181920212223242526272829303132333435363738394041package com.xiebin.day3;/** * @author 谢斌 * @create 2019-10-2019/10/15 18:34 */public class exer3 &#123; public static void main(String[] args) &#123; //求100以内的所有质数 /* * 思路分析: * 1.首先要明白质数含义:只能被1和他本身整除的数. * 2.对于某一个数a,可以试着让它除以a-1.....2,如果有任意一次除数为零,这个数a就不是质数. * 3.借助循环语句.外层循环遍历2-100之间的每一个整数(作为被除数). * 4.然后在内循环中用从2到它之间的数去除它,如果找到一个能整除它的数,内层循环将立即跳出. * * * */ /*方式一:标识i是否被j除进 * * */ boolean isFlag = true; //遍历2-100之间的所有整数(作为被除数) for (int i = 2; i &lt;= 100; i++) &#123; //遍历j,j作为除数(2-100) for (int j = 2; j &lt; i; j++) &#123; // if (i % j == 0) &#123; isFlag = false; &#125; &#125; if (isFlag == true) &#123; System.out.println("i = " + i); &#125; //重置isFlag isFlag = true; &#125; &#125;&#125; 优化: 1234567891011121314151617181920212223242526272829303132333435package com.xiebin.day3;/** * @author 谢斌 * @create 2019-10-2019/10/15 */public class exer3 &#123; public static void main(String[] args) &#123; boolean isFlag = true; int count = 0; //遍历2-100之间的所有整数(作为被除数) for (int i = 2; i &lt;= 100; i++) &#123; //遍历j,j作为除数(2-100) //优化二: for (int j = 2; j &lt;= Math.sqrt(i); j++) &#123; // if (i % j == 0) &#123; isFlag = false; //优化一:对本身不是质数的自然数有效 break; &#125; &#125; if (isFlag == true) &#123; // System.out.println("i = " + i); count++; &#125; //重置isFlag isFlag = true; &#125; System.out.println(" count = " + count); &#125;&#125; 方式二: 123456789101112131415161718192021package com.xiebin.day3;/** * @author 谢斌 * @create 2019-10-2019/10/15 */public class exer3 &#123; public static void main(String[] args) &#123; int count = 0; boolean isFlag = true; //遍历2-100之间的所有整数(作为被除数) label:for (int i = 2; i &lt;= 10000; i++) &#123; for (int j = 2; j &lt;= Math.sqrt(i); j++) &#123; if (i % j == 0) &#123; continue label; &#125; &#125; count++; &#125; System.out.println("count = " + count); &#125;&#125;]]></content>
      <categories>
        <category>JavaSE</category>
      </categories>
      <tags>
        <tag>Java基础</tag>
      </tags>
  </entry>
  <entry>
    <title><![CDATA[我的第一篇博客]]></title>
    <url>%2F%E6%88%91%E7%9A%84%E7%AC%AC%E4%B8%80%E7%AF%87%E5%8D%9A%E5%AE%A2.html</url>
    <content type="text"><![CDATA[¶前言 从今天开始,就正式开始我的java学习之旅了,本博客主要记录我的学习情况以及心得,小白一枚,博客之中有不当之处,还请各位多多指教,共同进步.]]></content>
  </entry>
</search>
